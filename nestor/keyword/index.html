
<!DOCTYPE html>

<html class="no-js" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<meta content="Quantifying tacit human knowledge for Smart Manufacturing Maintenance, for maintnenance-based investigatory analysis" name="description"/>
<meta content="Thurston Sexton" name="author"/>
<link href="../../media/favicon.png" rel="shortcut icon"/>
<meta content="mkdocs-1.2.2, mkdocs-material-5.5.14" name="generator"/>
<title>keyword - Nestor</title>
<link href="../../assets/stylesheets/main.d3202873.min.css" rel="stylesheet"/>
<link href="../../assets/stylesheets/palette.ff0a5ce4.min.css" rel="stylesheet"/>
<meta content="#546d78" name="theme-color"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&amp;display=fallback" rel="stylesheet"/>
<style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
<link href="../../assets/_mkdocstrings.css" rel="stylesheet"/>
<link href="https://pages.nist.gov/nist-header-footer/css/nist-combined.css" rel="stylesheet"/>
<link href="../../css/ansi-colours.css" rel="stylesheet"/>
<link href="../../css/jupyter-cells.css" rel="stylesheet"/>
<link href="../../css/pandas-dataframe.css" rel="stylesheet"/>
</head>
<body data-md-color-accent="orange" data-md-color-primary="blue-grey" data-md-color-scheme="" dir="ltr">
<input autocomplete="off" class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/>
<input autocomplete="off" class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/>
<label class="md-overlay" for="__drawer"></label>
<div data-md-component="skip">
<a class="md-skip" href="#nestorkeyword">
          Skip to content
        </a>
</div>
<div data-md-component="announce">
</div>
<header class="md-header" data-md-component="header">
<nav aria-label="Header" class="md-header-nav md-grid">
<a aria-label="Nestor" class="md-header-nav__button md-logo" href="../.." title="Nestor">
<img alt="logo" src="../../media/icon.png"/>
</a>
<label class="md-header-nav__button md-icon" for="__drawer">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"></path></svg>
</label>
<div class="md-header-nav__title" data-md-component="header-title">
<div class="md-header-nav__ellipsis">
<span class="md-header-nav__topic md-ellipsis">
            Nestor
          </span>
<span class="md-header-nav__topic md-ellipsis">
            
              keyword
            
          </span>
</div>
</div>
<label class="md-header-nav__button md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"></path></svg>
</label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input aria-label="Search" autocapitalize="off" autocomplete="off" autocorrect="off" class="md-search__input" data-md-component="search-query" data-md-state="active" name="query" placeholder="Search" spellcheck="false" type="text"/>
<label class="md-search__icon md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"></path></svg>
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"></path></svg>
</label>
<button aria-label="Clear" class="md-search__icon md-icon" data-md-component="search-reset" tabindex="-1" type="reset">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"></path></svg>
</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix="">
<div class="md-search-result" data-md-component="search-result">
<div class="md-search-result__meta">
            Initializing search
          </div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>
</nav>
</header>
<div class="md-container" data-md-component="container">
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="Navigation" class="md-nav md-nav--primary" data-md-level="0">
<label class="md-nav__title" for="__drawer">
<a aria-label="Nestor" class="md-nav__button md-logo" href="../.." title="Nestor">
<img alt="logo" src="../../media/icon.png"/>
</a>
    Nestor
  </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../.." title="Home">
      Home
    </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../LICENSE/" title="License">
      License
    </a>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" id="nav-3" type="checkbox"/>
<label class="md-nav__link" for="nav-3">
      Getting Started
      <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Getting Started" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="nav-3">
<span class="md-nav__icon md-icon"></span>
        Getting Started
      </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../getting-started/" title="Install &amp; Setup">
      Install &amp; Setup
    </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../motivation/" title="Motivation">
      Motivation
    </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../workflow/" title="Workflow">
      Workflow
    </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../gui-links/" title="User Interfaces">
      User Interfaces
    </a>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="nav-5" id="nav-5" type="checkbox"/>
<label class="md-nav__link" for="nav-5">
      Examples
      <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Examples" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="nav-5">
<span class="md-nav__icon md-icon"></span>
        Examples
      </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../examples/survival-analysis/survival-analysis/" title="Survival Analysis">
      Survival Analysis
    </a>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="nav-5-2" id="nav-5-2" type="checkbox"/>
<label class="md-nav__link" for="nav-5-2">
      Named Entity Recognition
      <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Named Entity Recognition" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="nav-5-2">
<span class="md-nav__icon md-icon"></span>
        Named Entity Recognition
      </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../examples/named-entities/01-BIO-format/" title="IOB Format Intro">
      IOB Format Intro
    </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../examples/named-entities/02-NER-example-NLTK/" title="02 NER example NLTK">
      02 NER example NLTK
    </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../examples/named-entities/03-NER-example-Spacy/" title="03 NER example Spacy">
      03 NER example Spacy
    </a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--active md-nav__item--nested">
<input checked="" class="md-nav__toggle md-toggle" data-md-toggle="nav-6" id="nav-6" type="checkbox"/>
<label class="md-nav__link" for="nav-6">
      API Reference
      <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="API Reference" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="nav-6">
<span class="md-nav__icon md-icon"></span>
        API Reference
      </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../settings/" title="settings">
      settings
    </a>
</li>
<li class="md-nav__item md-nav__item--active">
<input class="md-nav__toggle md-toggle" data-md-toggle="toc" id="__toc" type="checkbox"/>
<label class="md-nav__link md-nav__link--active" for="__toc">
        keyword
        <span class="md-nav__icon md-icon"></span>
</label>
<a class="md-nav__link md-nav__link--active" href="./" title="keyword">
      keyword
    </a>
<nav aria-label="Table of contents" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword">
    nestor.keyword
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.NLPSelect">
    NLPSelect
  </a>
<nav aria-label="NLPSelect" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.NLPSelect.get_params">
    get_params()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.NLPSelect.transform">
    transform()
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TagExtractor">
    TagExtractor
  </a>
<nav aria-label="TagExtractor" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TagExtractor.__init__">
    __init__()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TagExtractor.fit">
    fit()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TagExtractor.fit_transform">
    fit_transform()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TagExtractor.transform">
    transform()
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TagRep">
    TagRep
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TokenExtractor">
    TokenExtractor
  </a>
<nav aria-label="TokenExtractor" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TokenExtractor.ranks_">
    ranks_
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TokenExtractor.scores_">
    scores_
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TokenExtractor.sumtfidf_">
    sumtfidf_
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TokenExtractor.vocab_">
    vocab_
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TokenExtractor.__init__">
    __init__()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TokenExtractor.fit">
    fit()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TokenExtractor.fit_transform">
    fit_transform()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TokenExtractor.thesaurus_template">
    thesaurus_template()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TokenExtractor.transform">
    transform()
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.generate_vocabulary_df">
    generate_vocabulary_df()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.get_multilabel_representation">
    get_multilabel_representation()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.get_tag_completeness">
    get_tag_completeness()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.iob_extractor">
    iob_extractor()
  </a>
<nav aria-label="iob_extractor()" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.iob_extractor--parameters">
    Parameters
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.ngram_automatch">
    ngram_automatch()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.ngram_keyword_pipe">
    ngram_keyword_pipe()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.ngram_vocab_builder">
    ngram_vocab_builder()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.pick_tag_types">
    pick_tag_types()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.regex_match_vocab">
    regex_match_vocab()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.regex_thesaurus_normalizer">
    regex_thesaurus_normalizer()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.tag_extractor">
    tag_extractor()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.token_to_alias">
    token_to_alias()
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../datasets/" title="datasets">
      datasets
    </a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="Table of contents" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword">
    nestor.keyword
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.NLPSelect">
    NLPSelect
  </a>
<nav aria-label="NLPSelect" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.NLPSelect.get_params">
    get_params()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.NLPSelect.transform">
    transform()
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TagExtractor">
    TagExtractor
  </a>
<nav aria-label="TagExtractor" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TagExtractor.__init__">
    __init__()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TagExtractor.fit">
    fit()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TagExtractor.fit_transform">
    fit_transform()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TagExtractor.transform">
    transform()
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TagRep">
    TagRep
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TokenExtractor">
    TokenExtractor
  </a>
<nav aria-label="TokenExtractor" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TokenExtractor.ranks_">
    ranks_
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TokenExtractor.scores_">
    scores_
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TokenExtractor.sumtfidf_">
    sumtfidf_
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TokenExtractor.vocab_">
    vocab_
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TokenExtractor.__init__">
    __init__()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TokenExtractor.fit">
    fit()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TokenExtractor.fit_transform">
    fit_transform()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TokenExtractor.thesaurus_template">
    thesaurus_template()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.TokenExtractor.transform">
    transform()
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.generate_vocabulary_df">
    generate_vocabulary_df()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.get_multilabel_representation">
    get_multilabel_representation()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.get_tag_completeness">
    get_tag_completeness()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.iob_extractor">
    iob_extractor()
  </a>
<nav aria-label="iob_extractor()" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.iob_extractor--parameters">
    Parameters
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.ngram_automatch">
    ngram_automatch()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.ngram_keyword_pipe">
    ngram_keyword_pipe()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.ngram_vocab_builder">
    ngram_vocab_builder()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.pick_tag_types">
    pick_tag_types()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.regex_match_vocab">
    regex_match_vocab()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.regex_thesaurus_normalizer">
    regex_thesaurus_normalizer()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.tag_extractor">
    tag_extractor()
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nestor.keyword.token_to_alias">
    token_to_alias()
  </a>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<h1 id="nestorkeyword"><code>nestor.keyword</code></h1>
<div class="doc doc-object doc-module">
<a id="nestor.keyword"></a>
<div class="doc doc-contents first">
<div class="doc doc-children">
<div class="doc doc-object doc-class">
<h2 class="doc doc-heading" id="nestor.keyword.NLPSelect">
<code>NLPSelect</code>
</h2>
<div class="doc doc-contents">
<p>Extract specified natural language columns</p>
<p>Starting from a pd.DataFrame, combine <code>columns</code> into a single series
containing lowercased text with punctuation and excess newlines removed.
Using the <code>special_replace</code> dict allows for arbitrary mapping during the
cleaning process, for e.g. a priori normalization.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>columns(int,list</code></td>
<td><code>of int,str</code></td>
<td><p>names/positions of data columns to extract, clean, and merge</p></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>special_replace(dict,None)</code></td>
<td><code></code></td>
<td><p>mapping from strings to normalized strings (known a priori)</p></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>together(pd.Series)</code></td>
<td><code></code></td>
<td><p>merged text, before any cleaning/normalization</p></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>clean_together(pd.Series)</code></td>
<td><code></code></td>
<td><p>merged text, after cleaning (output of <code>transform</code>)</p></td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="nestor.keyword.NLPSelect.get_params">
<code class="highlight language-python"><span class="n">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>
</h3>
<div class="doc doc-contents">
<p>Retrieve parameters of the transformer for sklearn compatibility.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>deep</code></td>
<td><code></code></td>
<td><p>(Default value = True)</p></td>
<td><code>True</code></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">"""Retrieve parameters of the transformer for sklearn compatibility.</span>

<span class="sd">    Args:</span>
<span class="sd">      deep:  (Default value = True)</span>

<span class="sd">    Returns:</span>

<span class="sd">    """</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">special_replace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">special_replace</span>
    <span class="p">)</span>
</code></pre></div>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="nestor.keyword.NLPSelect.transform">
<code class="highlight language-python"><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>
</h3>
<div class="doc doc-contents">
<p>get clean column of text from column(s) of raw text in a dataset</p>
<p>Depending on which of Union[List[Union[int,str]],int,str]
<code>self.columns</code> is, this will extract desired columns (of text) from
positions, names, etc. in the original dataset <code>X</code>.</p>
<p>Columns will be merged, lowercased, and have punctuation and hanging
newlines removed.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>X(pandas.DataFrome)</code></td>
<td><code></code></td>
<td><p>dataset containing certain columns with natural language text.</p></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>y(None,</code></td>
<td><code>optional</code></td>
<td><p>(Default value = None)</p></td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>clean_together(pd.Series)</code></td>
<td><p>a single column of merged, cleaned text</p></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""get clean column of text from column(s) of raw text in a dataset</span>

<span class="sd">    Depending on which of Union[List[Union[int,str]],int,str]</span>
<span class="sd">    `self.columns` is, this will extract desired columns (of text) from</span>
<span class="sd">    positions, names, etc. in the original dataset `X`.</span>

<span class="sd">    Columns will be merged, lowercased, and have punctuation and hanging</span>
<span class="sd">    newlines removed.</span>

<span class="sd">    Args:</span>
<span class="sd">      X(pandas.DataFrome): dataset containing certain columns with natural language text.</span>
<span class="sd">      y(None, optional):  (Default value = None)</span>

<span class="sd">    Returns:</span>
<span class="sd">       clean_together(pd.Series): a single column of merged, cleaned text</span>

<span class="sd">    """</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>  <span class="c1"># user passed a list of column labels</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">]):</span>
            <span class="n">nlp_cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
            <span class="p">)</span>  <span class="c1"># select columns by user-input indices</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">]):</span>
            <span class="n">nlp_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>  <span class="c1"># select columns by user-input names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"Select error: mixed or wrong column type."</span><span class="p">)</span>  <span class="c1"># can't do both</span>
            <span class="k">raise</span> <span class="ne">Exception</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>  <span class="c1"># take in a single index</span>
        <span class="n">nlp_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nlp_cols</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>  <span class="c1"># allow...duck-typing I guess? Don't remember.</span>

    <span class="k">def</span> <span class="nf">_robust_cat</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">cols</span><span class="p">):</span>
        <span class="sd">"""pandas doesn't like batch-cat of string cols...needs 1st col</span>

<span class="sd">        Args:</span>
<span class="sd">          df:</span>
<span class="sd">          cols:</span>

<span class="sd">        Returns:</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s2">""</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">df</span><span class="p">[</span><span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
                <span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">cols</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">),</span> <span class="n">sep</span><span class="o">=</span><span class="s2">" "</span><span class="p">,</span> <span class="n">na_rep</span><span class="o">=</span><span class="s2">""</span><span class="p">,)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_clean_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">special_replace</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""lower, rm newlines and punct, and optionally special words</span>

<span class="sd">        Args:</span>
<span class="sd">          s:</span>
<span class="sd">          special_replace:  (Default value = None)</span>

<span class="sd">        Returns:</span>

<span class="sd">        """</span>
        <span class="n">raw_text</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>  <span class="c1"># all lowercase</span>
            <span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">,</span> <span class="s2">" "</span><span class="p">)</span>  <span class="c1"># no hanging newlines</span>
            <span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">"[</span><span class="si">{}</span><span class="s2">]"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">punctuation</span><span class="p">),</span> <span class="s2">" "</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">special_replace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rx</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">"|"</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">,</span> <span class="n">special_replace</span><span class="p">)))</span>
            <span class="c1"># allow user-input special replacements.</span>
            <span class="k">return</span> <span class="n">raw_text</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                <span class="n">rx</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">match</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">special_replace</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">raw_text</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">together</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">_robust_cat</span><span class="p">,</span> <span class="n">nlp_cols</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">clean_together</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">together</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span>
        <span class="n">_clean_text</span><span class="p">,</span> <span class="n">special_replace</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">special_replace</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clean_together</span>
</code></pre></div>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h2 class="doc doc-heading" id="nestor.keyword.TagExtractor">
<code>TagExtractor</code>
</h2>
<div class="doc doc-contents">
<p>Wrapper for <a href="nestor.keyword.TokenExtractor">TokenExtractor</a> to apply a <em>Nestor</em> thesaurus or vocabulary
definition on-top of the token extraction process. Also provides several useful methods as a result.</p>
<div class="doc doc-children">
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="nestor.keyword.TagExtractor.__init__">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thesaurus</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">group_untagged</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">filter_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output_type</span><span class="o">=&lt;</span><span class="n">TagRep</span><span class="o">.</span><span class="n">binary</span><span class="p">:</span> <span class="s1">'binary'</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">**</span><span class="n">tfidf_kwargs</span><span class="p">)</span></code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
</h3>
<div class="doc doc-contents">
<p>Identical to the <a href="nestor.keyword.TokenExtractor">TokenExtractor</a> initialization,
Except for the addition of an optional <code>vocab</code> argument that allows for pre-defined
thesaurus/dictionary mappings of tokens to named entities
(see <a href="nestor.keyword.generate_vocabulary_df">generate_vocabulary_df</a>)
to get used in the transformation doc-term form.</p>
<p>Rather than outputting a TF-IDF-weighted sparse matrix, this transformer outputs a Multi-column
<code>pd.DataFrame</code> with the top-level columns being current tag-types in <code>nestor.CFG</code>, and the sub-level
being the actual tokens/compound-tokens.</p>
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">thesaurus</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">group_untagged</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">filter_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">output_type</span><span class="p">:</span> <span class="n">TagRep</span> <span class="o">=</span> <span class="n">TagRep</span><span class="p">[</span><span class="s2">"binary"</span><span class="p">],</span>
    <span class="o">**</span><span class="n">tfidf_kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Identical to the [TokenExtractor](nestor.keyword.TokenExtractor) initialization,</span>
<span class="sd">    Except for the addition of an optional `vocab` argument that allows for pre-defined</span>
<span class="sd">    thesaurus/dictionary mappings of tokens to named entities</span>
<span class="sd">    (see [generate_vocabulary_df](nestor.keyword.generate_vocabulary_df))</span>
<span class="sd">    to get used in the transformation doc-term form.</span>

<span class="sd">    Rather than outputting a TF-IDF-weighted sparse matrix, this transformer outputs a Multi-column</span>
<span class="sd">    `pd.DataFrame` with the top-level columns being current tag-types in `nestor.CFG`, and the sub-level</span>
<span class="sd">    being the actual tokens/compound-tokens.</span>

<span class="sd">    """</span>
    <span class="c1"># super().__init__()</span>
    <span class="n">default_kws</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="nb">input</span><span class="o">=</span><span class="s2">"content"</span><span class="p">,</span>
        <span class="n">ngram_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">stop_words</span><span class="o">=</span><span class="s2">"english"</span><span class="p">,</span>
        <span class="n">sublinear_tf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">smooth_idf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">max_features</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
        <span class="n">token_pattern</span><span class="o">=</span><span class="n">nestorParams</span><span class="o">.</span><span class="n">token_pattern</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">default_kws</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">tfidf_kwargs</span><span class="p">)</span>

    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">default_kws</span><span class="p">)</span>  <span class="c1"># get internal attrs from parent</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_tokenmodel</span> <span class="o">=</span> <span class="n">TokenExtractor</span><span class="p">(</span>
        <span class="o">**</span><span class="n">default_kws</span>
    <span class="p">)</span>  <span class="c1"># persist an instance for composition</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">group_untagged</span> <span class="o">=</span> <span class="n">group_untagged</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">filter_types</span> <span class="o">=</span> <span class="n">filter_types</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">output_type</span> <span class="o">=</span> <span class="n">output_type</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span> <span class="o">=</span> <span class="n">verbose</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_thesaurus</span> <span class="o">=</span> <span class="n">thesaurus</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tfidf_</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">tag_df_</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">iob_rep_</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">multi_rep_</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">tag_completeness_</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">num_complete_docs_</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">num_empty_docs_</span> <span class="o">=</span> <span class="kc">None</span>
</code></pre></div>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="nestor.keyword.TagExtractor.fit">
<code class="highlight language-python"><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">documents</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>
</h3>
<div class="doc doc-contents">
<p>Learn a vocabulary dictionary of tokens in raw documents.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>documents</code></td>
<td><code>pd.Series, Iterable</code></td>
<td><p>Iterable of raw documents</p></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>y</code></td>
<td><code></code></td>
<td><p>(Default value = None)</p></td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td><p>self</p></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">documents</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># self._tokenmodel.fit(documents)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tfidf_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokenmodel</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">documents</span><span class="p">)</span>
    <span class="c1"># check_is_fitted(self._tokenmodel, msg="The tfidf vector is not fitted")</span>
    <span class="n">tag_df</span> <span class="o">=</span> <span class="n">tag_extractor</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tokenmodel</span><span class="p">,</span>
        <span class="n">documents</span><span class="p">,</span>
        <span class="n">vocab_df</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">thesaurus</span><span class="p">,</span>
        <span class="n">group_untagged</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">group_untagged</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_types</span><span class="p">:</span>
        <span class="n">tag_df</span> <span class="o">=</span> <span class="n">pick_tag_types</span><span class="p">(</span><span class="n">tag_df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_types</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">tag_df</span> <span class="o">=</span> <span class="n">tag_df</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tags_as_iob</span> <span class="o">=</span> <span class="n">documents</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tags_as_lists</span> <span class="o">=</span> <span class="n">tag_df</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">set_stats</span><span class="p">()</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">report_completeness</span><span class="p">()</span>
    <span class="k">return</span> <span class="bp">self</span>
</code></pre></div>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="nestor.keyword.TagExtractor.fit_transform">
<code class="highlight language-python"><span class="n">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">documents</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>
</h3>
<div class="doc doc-contents">
<p>Turn TokenExtractor instances and raw-text into binary occurrences.</p>
<p>Wrapper for the TokenExtractor to streamline the generation of tags from text.
Determines the documents in <code>raw_text</code> that contain each of the tags in <code>vocab_df</code>,
using a TokenExtractor self object (i.e. the tfidf vocabulary).</p>
<p>As implemented, this function expects an existing self object, though in
the future this may be changed to a class-like functionality (e.g. sklearn's
AdaBoostClassifier, etc) which wraps a self into a new one.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>self</code></td>
<td><code>object KeywordExtractor</code></td>
<td><p>instantiated, can be pre-trained</p></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>raw_text</code></td>
<td><code>pd.Series</code></td>
<td><p>contains jargon/slang-filled raw text to be tagged</p></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>vocab_df</code></td>
<td><code>pd.DataFrame</code></td>
<td><p>An existing vocabulary dataframe or .csv filename, expected in the format of
 kex.generate_vocabulary_df(). (Default value = None)</p></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>readable</code></td>
<td><code>bool</code></td>
<td><p>whether to return readable, categorized, comma-sep str format (takes longer) (Default value = False)</p></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>group_untagged</code></td>
<td><code>bool</code></td>
<td><p>whether to group untagged tokens into a catch-all "_untagged" tag</p></td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pd.DataFrame</code></td>
<td><p>extracted tags for each document, whether binary indicator (default)
or in readable, categorized, comma-sep str format (readable=True, takes longer)</p></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="nd">@documented_at</span><span class="p">(</span><span class="n">tag_extractor</span><span class="p">,</span> <span class="n">transformer</span><span class="o">=</span><span class="s2">"self"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">documents</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""Fit transformer on `documents` and return the binary, hierarchical """</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">documents</span><span class="p">)</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">documents</span><span class="p">)</span>
</code></pre></div>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="nestor.keyword.TagExtractor.transform">
<code class="highlight language-python"><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">documents</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>
</h3>
<div class="doc doc-contents">
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">documents</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    """</span>
    <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"tag_df_"</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_type</span> <span class="o">==</span> <span class="n">TagRep</span><span class="o">.</span><span class="n">multilabel</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags_as_lists</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_type</span> <span class="o">==</span> <span class="n">TagRep</span><span class="o">.</span><span class="n">iob</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags_as_iob</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag_df</span>
</code></pre></div>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h2 class="doc doc-heading" id="nestor.keyword.TagRep">
<code>TagRep</code>
</h2>
<div class="doc doc-contents">
<p>available representation of tags in documents</p>
<div class="doc doc-children">
</div>
</div>
</div>
<div class="doc doc-object doc-class">
<h2 class="doc doc-heading" id="nestor.keyword.TokenExtractor">
<code>TokenExtractor</code>
</h2>
<div class="doc doc-contents">
<p>A wrapper for the sklearn TfidfVectorizer class, with utilities for ranking by
total tf-idf score, and getting a list of vocabulary.</p>
<p>Valid options are given below from sklearn docs.</p>
<div class="doc doc-children">
<div class="doc doc-object doc-attribute">
<h3 class="doc doc-heading" id="nestor.keyword.TokenExtractor.ranks_">
<code class="highlight language-python"><span class="n">ranks_</span></code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-property"><code>property</code></small>
<small class="doc doc-property doc-property-writable"><code>writable</code></small>
</span>
</h3>
<div class="doc doc-contents">
<p>Retrieve the rank of each token, for sorting. Uses summed scoring over the
TF-IDF for each token, so that: <span><span class="MathJax_Preview">S_t = \Sum_{d  ext{TF-IDF}_t</span><script type="math/tex">S_t = \Sum_{d  ext{TF-IDF}_t</script></span></p>
</div>
</div>
<div class="doc doc-object doc-attribute">
<h3 class="doc doc-heading" id="nestor.keyword.TokenExtractor.scores_">
<code class="highlight language-python"><span class="n">scores_</span></code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-property"><code>property</code></small>
<small class="doc doc-property doc-property-writable"><code>writable</code></small>
</span>
</h3>
<div class="doc doc-contents">
<p>Returns actual scores of tokens, for progress-tracking (min-max-normalized)</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>numpy.array</code></td>
<td></td>
</tr>
</tbody>
</table> </div>
</div>
<div class="doc doc-object doc-attribute">
<h3 class="doc doc-heading" id="nestor.keyword.TokenExtractor.sumtfidf_">
<code class="highlight language-python"><span class="n">sumtfidf_</span></code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-property"><code>property</code></small>
<small class="doc doc-property doc-property-writable"><code>writable</code></small>
</span>
</h3>
<div class="doc doc-contents">
<p>sum of the tf-idf scores for each token over all documents.</p>
<p>Thought to approximate mutual information content of a given string.</p>
</div>
</div>
<div class="doc doc-object doc-attribute">
<h3 class="doc doc-heading" id="nestor.keyword.TokenExtractor.vocab_">
<code class="highlight language-python"><span class="n">vocab_</span></code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-property"><code>property</code></small>
<small class="doc doc-property doc-property-writable"><code>writable</code></small>
</span>
</h3>
<div class="doc doc-contents">
<p>ordered list of tokens, rank-ordered by summed-tf-idf
(see :func:<code>~nestor.keyword.TokenExtractor.ranks_</code>)</p>
</div>
</div>
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="nestor.keyword.TokenExtractor.__init__">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="s1">'content'</span><span class="p">,</span> <span class="n">ngram_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">stop_words</span><span class="o">=</span><span class="s1">'english'</span><span class="p">,</span> <span class="n">sublinear_tf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">smooth_idf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_features</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">token_pattern</span><span class="o">=</span><span class="s1">'</span><span class="se">\\</span><span class="s1">b</span><span class="se">\\</span><span class="s1">w</span><span class="se">\\</span><span class="s1">w+</span><span class="se">\\</span><span class="s1">b'</span><span class="p">,</span> <span class="o">**</span><span class="n">tfidf_kwargs</span><span class="p">)</span></code>
<span class="doc doc-properties">
<small class="doc doc-property doc-property-special"><code>special</code></small>
</span>
</h3>
<div class="doc doc-contents">
<p>Initialize the extractor</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>input</code></td>
<td><code>string</code></td>
<td><p>{'filename', 'file', 'content'}
  If 'filename', the sequence passed as an argument to fit is
  expected to be a list of filenames that need reading to fetch
  the raw content to analyze.</p>
<p>If 'file', the sequence items must have a 'read' method (file-like
  object) that is called to fetch the bytes in memory.
  Otherwise the input is expected to be the sequence strings or
  bytes items are expected to be analyzed directly.</p></td>
<td><code>'content'</code></td>
</tr>
<tr>
<td><code>ngram_range</code></td>
<td><code>tuple</code></td>
<td><p>(min_n, max_n), default=(1,1)
  The lower and upper boundary of the range of n-values for different
  n-grams to be extracted. All values of n such that min_n &lt;= n &lt;= max_n
  will be used.</p></td>
<td><code>(1, 1)</code></td>
</tr>
<tr>
<td><code>stop_words</code></td>
<td><code>string</code></td>
<td><p>{'english'} (default), list, or None
  If a string, it is passed to _check_stop_list and the appropriate stop
  list is returned. 'english' is currently the only supported string
  value.</p>
<p>If a list, that list is assumed to contain stop words, all of which
  will be removed from the resulting tokens.
  Only applies if <code>analyzer == 'word'</code>.</p>
<p>If None, no stop words will be used. max_df can be set to a value
  in the range [0.7, 1.0) to automatically detect and filter stop
  words based on intra corpus document frequency of terms.</p></td>
<td><code>'english'</code></td>
</tr>
<tr>
<td><code>max_features</code></td>
<td><code>int or None</code></td>
<td><p>If not None, build a vocabulary that only consider the top
  max_features ordered by term frequency across the corpus.
  This parameter is ignored if vocabulary is not None.
  (default=5000)</p></td>
<td><code>5000</code></td>
</tr>
<tr>
<td><code>smooth_idf</code></td>
<td><code>boolean</code></td>
<td><p>Smooth idf weights by adding one to document frequencies, as if an
  extra document was seen containing every term in the collection
  exactly once. Prevents zero divisions. (default=False)</p></td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>sublinear_tf</code></td>
<td><code>boolean</code></td>
<td><p>(Default value = True)
  Apply sublinear tf scaling, i.e. replace tf with 1 + log(tf).</p></td>
<td><code>True</code></td>
</tr>
<tr>
<td><code>**tfidf_kwargs</code></td>
<td><code></code></td>
<td><p>other arguments passed to <code>sklearn.TfidfVectorizer</code></p></td>
<td><code>{}</code></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="nb">input</span><span class="o">=</span><span class="s2">"content"</span><span class="p">,</span>
    <span class="n">ngram_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">stop_words</span><span class="o">=</span><span class="s2">"english"</span><span class="p">,</span>
    <span class="n">sublinear_tf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">smooth_idf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">max_features</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
    <span class="n">token_pattern</span><span class="o">=</span><span class="n">nestorParams</span><span class="o">.</span><span class="n">token_pattern</span><span class="p">,</span>
    <span class="o">**</span><span class="n">tfidf_kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">"""Initialize the extractor</span>

<span class="sd">    Args:</span>
<span class="sd">       input (string): {'filename', 'file', 'content'}</span>
<span class="sd">            If 'filename', the sequence passed as an argument to fit is</span>
<span class="sd">            expected to be a list of filenames that need reading to fetch</span>
<span class="sd">            the raw content to analyze.</span>

<span class="sd">            If 'file', the sequence items must have a 'read' method (file-like</span>
<span class="sd">            object) that is called to fetch the bytes in memory.</span>
<span class="sd">            Otherwise the input is expected to be the sequence strings or</span>
<span class="sd">            bytes items are expected to be analyzed directly.</span>
<span class="sd">       ngram_range (tuple): (min_n, max_n), default=(1,1)</span>
<span class="sd">            The lower and upper boundary of the range of n-values for different</span>
<span class="sd">            n-grams to be extracted. All values of n such that min_n &lt;= n &lt;= max_n</span>
<span class="sd">            will be used.</span>
<span class="sd">       stop_words (string): {'english'} (default), list, or None</span>
<span class="sd">            If a string, it is passed to _check_stop_list and the appropriate stop</span>
<span class="sd">            list is returned. 'english' is currently the only supported string</span>
<span class="sd">            value.</span>

<span class="sd">            If a list, that list is assumed to contain stop words, all of which</span>
<span class="sd">            will be removed from the resulting tokens.</span>
<span class="sd">            Only applies if ``analyzer == 'word'``.</span>

<span class="sd">            If None, no stop words will be used. max_df can be set to a value</span>
<span class="sd">            in the range [0.7, 1.0) to automatically detect and filter stop</span>
<span class="sd">            words based on intra corpus document frequency of terms.</span>
<span class="sd">       max_features (int or None):</span>
<span class="sd">            If not None, build a vocabulary that only consider the top</span>
<span class="sd">            max_features ordered by term frequency across the corpus.</span>
<span class="sd">            This parameter is ignored if vocabulary is not None.</span>
<span class="sd">            (default=5000)</span>
<span class="sd">       smooth_idf (boolean):</span>
<span class="sd">            Smooth idf weights by adding one to document frequencies, as if an</span>
<span class="sd">            extra document was seen containing every term in the collection</span>
<span class="sd">            exactly once. Prevents zero divisions. (default=False)</span>
<span class="sd">       sublinear_tf (boolean): (Default value = True)</span>
<span class="sd">            Apply sublinear tf scaling, i.e. replace tf with 1 + log(tf).</span>

<span class="sd">       **tfidf_kwargs: other arguments passed to `sklearn.TfidfVectorizer`</span>
<span class="sd">    """</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">default_kws</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="s2">"input"</span><span class="p">:</span> <span class="nb">input</span><span class="p">,</span>
            <span class="s2">"ngram_range"</span><span class="p">:</span> <span class="n">ngram_range</span><span class="p">,</span>
            <span class="s2">"stop_words"</span><span class="p">:</span> <span class="n">stop_words</span><span class="p">,</span>
            <span class="s2">"sublinear_tf"</span><span class="p">:</span> <span class="n">sublinear_tf</span><span class="p">,</span>
            <span class="s2">"smooth_idf"</span><span class="p">:</span> <span class="n">smooth_idf</span><span class="p">,</span>
            <span class="s2">"max_features"</span><span class="p">:</span> <span class="n">max_features</span><span class="p">,</span>
            <span class="s2">"token_pattern"</span><span class="p">:</span> <span class="n">token_pattern</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">default_kws</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tfidf_kwargs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="n">TfidfVectorizer</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">default_kws</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_tf_tot</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_ranks</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_vocab</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_scores</span> <span class="o">=</span> <span class="kc">None</span>
</code></pre></div>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="nestor.keyword.TokenExtractor.fit">
<code class="highlight language-python"><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">documents</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>
</h3>
<div class="doc doc-contents">
<p>Learn a vocabulary dictionary of tokens in raw documents.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>documents</code></td>
<td><code>pd.Series, Iterable</code></td>
<td><p>Iterable of raw documents</p></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>y</code></td>
<td><code></code></td>
<td><p>(Default value = None)</p></td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code></code></td>
<td><p>self</p></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">documents</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Learn a vocabulary dictionary of tokens in raw documents.</span>
<span class="sd">    Args:</span>
<span class="sd">      documents (pd.Series, Iterable): Iterable of raw documents</span>
<span class="sd">      y:  (Default value = None)</span>

<span class="sd">    Returns:</span>
<span class="sd">      self</span>
<span class="sd">    """</span>
    <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">documents</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>
</code></pre></div>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="nestor.keyword.TokenExtractor.fit_transform">
<code class="highlight language-python"><span class="n">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">documents</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">)</span></code>
</h3>
<div class="doc doc-contents">
<p>transform a container of text documents to TF-IDF Sparse Matrix</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>documents</code></td>
<td><code>pd.Series, Iterable</code></td>
<td><p>Iterable of raw documents</p></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>y</code></td>
<td><code></code></td>
<td><p>(Default value = None) unused</p></td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>**fit_params</code></td>
<td><code></code></td>
<td><p>kwargs passed to underlying TfidfVectorizer</p></td>
<td><code>{}</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>X_tf</code></td>
<td><p>array of shape (n_samples, n_features)
      document-term matrix</p></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">fit_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">documents</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_params</span><span class="p">):</span>
    <span class="sd">"""transform a container of text documents to TF-IDF Sparse Matrix</span>

<span class="sd">    Args:</span>
<span class="sd">      documents (pd.Series, Iterable): Iterable of raw documents</span>
<span class="sd">      y:  (Default value = None) unused</span>
<span class="sd">      **fit_params: kwargs passed to underlying TfidfVectorizer</span>

<span class="sd">    Returns:</span>
<span class="sd">      X_tf: array of shape (n_samples, n_features)</span>
<span class="sd">            document-term matrix</span>

<span class="sd">    """</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">documents</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
        <span class="n">documents</span> <span class="o">=</span> <span class="n">_series_itervals</span><span class="p">(</span><span class="n">documents</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">X_tf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">documents</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">X_tf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">documents</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sumtfidf_</span> <span class="o">=</span> <span class="n">X_tf</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">ranks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sumtfidf_</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ranks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_kws</span><span class="p">[</span><span class="s2">"max_features"</span><span class="p">]:</span>
        <span class="n">ranks</span> <span class="o">=</span> <span class="n">ranks</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_kws</span><span class="p">[</span><span class="s2">"max_features"</span><span class="p">]]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ranks_</span> <span class="o">=</span> <span class="n">ranks</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">vocab_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">get_feature_names</span><span class="p">())[</span><span class="bp">self</span><span class="o">.</span><span class="n">ranks_</span><span class="p">]</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sumtfidf_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ranks_</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">scores_</span> <span class="o">=</span> <span class="p">(</span><span class="n">scores</span> <span class="o">-</span> <span class="n">scores</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">scores</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">scores</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">X_tf</span>
</code></pre></div>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="nestor.keyword.TokenExtractor.thesaurus_template">
<code class="highlight language-python"><span class="n">thesaurus_template</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>
</h3>
<div class="doc doc-contents">
<p>make correctly formatted entity vocabulary (token-&gt;tag+type)</p>
<p>Helper method to create a formatted pandas.DataFrame and/or a .csv containing
the token--tag/alias--classification relationship. Formatted as jargon/slang tokens,
the Named Entity classifications, preferred labels, notes, and tf-idf summed scores:</p>
<table>
<thead>
<tr>
<th>tokens</th>
<th>NE</th>
<th>alias</th>
<th>notes</th>
<th>scores</th>
</tr>
</thead>
<tbody>
<tr>
<td>myexample</td>
<td>I</td>
<td>example</td>
<td>"e.g"</td>
<td>0.42</td>
</tr>
</tbody>
</table>
<p>This is intended to be filled out in excel or using the Tagging Tool UI</p>
<ul>
<li><a href="https://github.com/usnistgov/nestor-qt"><code>nestor-qt</code></a></li>
<li><a href="https://github.com/usnistgov/nestor-web"><code>nestor-web</code></a></li>
</ul>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>self</code></td>
<td><code>TokenExtractor</code></td>
<td><p>the (TRAINED) token extractor used to generate the ranked list of vocab.</p></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>init</code></td>
<td><code>str or pd.Dataframe</code></td>
<td><p>file location of csv or dataframe of existing vocab list to read and update
token classification values from</p></td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pd.Dataframe</code></td>
<td><p>the correctly formatted vocabulary list for token:NE, alias matching</p></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="nd">@documented_at</span><span class="p">(</span><span class="n">generate_vocabulary_df</span><span class="p">,</span> <span class="n">transformer</span><span class="o">=</span><span class="s2">"self"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">thesaurus_template</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">generate_vocabulary_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="n">init</span><span class="p">)</span>
</code></pre></div>
</details>
</div>
</div>
<div class="doc doc-object doc-method">
<h3 class="doc doc-heading" id="nestor.keyword.TokenExtractor.transform">
<code class="highlight language-python"><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">documents</span><span class="p">)</span></code>
</h3>
<div class="doc doc-contents">
<p>transform documents into document-term matrix</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>documents</code></td>
<td><code></code></td>
<td></td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>X_tf</code></td>
<td><p>array of shape (n_samples, n_features)
      document-term matrix</p></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">documents</span><span class="p">):</span>
    <span class="sd">"""transform documents into document-term matrix</span>

<span class="sd">    Args:</span>
<span class="sd">      documents:</span>

<span class="sd">    Returns:</span>
<span class="sd">      X_tf: array of shape (n_samples, n_features)</span>
<span class="sd">            document-term matrix</span>


<span class="sd">    """</span>

    <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s2">"The tfidf vector is not fitted"</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">documents</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">_series_itervals</span><span class="p">(</span><span class="n">documents</span><span class="p">)</span>
    <span class="n">X_tf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sumtfidf_</span> <span class="o">=</span> <span class="n">X_tf</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">X_tf</span>
</code></pre></div>
</details>
</div>
</div>
</div>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="nestor.keyword.generate_vocabulary_df">
<code class="highlight language-python"><span class="n">generate_vocabulary_df</span><span class="p">(</span><span class="n">transformer</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>
</h2>
<div class="doc doc-contents">
<p>make correctly formatted entity vocabulary (token-&gt;tag+type)</p>
<p>Helper method to create a formatted pandas.DataFrame and/or a .csv containing
the token--tag/alias--classification relationship. Formatted as jargon/slang tokens,
the Named Entity classifications, preferred labels, notes, and tf-idf summed scores:</p>
<table>
<thead>
<tr>
<th>tokens</th>
<th>NE</th>
<th>alias</th>
<th>notes</th>
<th>scores</th>
</tr>
</thead>
<tbody>
<tr>
<td>myexample</td>
<td>I</td>
<td>example</td>
<td>"e.g"</td>
<td>0.42</td>
</tr>
</tbody>
</table>
<p>This is intended to be filled out in excel or using the Tagging Tool UI</p>
<ul>
<li><a href="https://github.com/usnistgov/nestor-qt"><code>nestor-qt</code></a></li>
<li><a href="https://github.com/usnistgov/nestor-web"><code>nestor-web</code></a></li>
</ul>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>transformer</code></td>
<td><code>TokenExtractor</code></td>
<td><p>the (TRAINED) token extractor used to generate the ranked list of vocab.</p></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>init</code></td>
<td><code>Union[str, pandas.core.frame.DataFrame]</code></td>
<td><p>file location of csv or dataframe of existing vocab list to read and update
token classification values from</p></td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pd.Dataframe</code></td>
<td><p>the correctly formatted vocabulary list for token:NE, alias matching</p></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">generate_vocabulary_df</span><span class="p">(</span>
    <span class="n">transformer</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">):</span>
    <span class="sd">""" make correctly formatted entity vocabulary (token-&gt;tag+type)</span>

<span class="sd">    Helper method to create a formatted pandas.DataFrame and/or a .csv containing</span>
<span class="sd">    the token--tag/alias--classification relationship. Formatted as jargon/slang tokens,</span>
<span class="sd">    the Named Entity classifications, preferred labels, notes, and tf-idf summed scores:</span>

<span class="sd">    tokens | NE | alias | notes | scores</span>
<span class="sd">    --- | --- | --- | --- | ---</span>
<span class="sd">    myexample| I | example | "e.g"| 0.42</span>

<span class="sd">    This is intended to be filled out in excel or using the Tagging Tool UI</span>

<span class="sd">    - [`nestor-qt`](https://github.com/usnistgov/nestor-qt)</span>
<span class="sd">    - [`nestor-web`](https://github.com/usnistgov/nestor-web)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        transformer (TokenExtractor): the (TRAINED) token extractor used to generate the ranked list of vocab.</span>
<span class="sd">        filename (str, optional) the file location to read/write a csv containing a formatted vocabulary list</span>
<span class="sd">        init (str or pd.Dataframe, optional): file location of csv or dataframe of existing vocab list to read and update</span>
<span class="sd">            token classification values from</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.Dataframe: the correctly formatted vocabulary list for token:NE, alias matching</span>
<span class="sd">    """</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">check_is_fitted</span><span class="p">(</span>
            <span class="n">transformer</span><span class="o">.</span><span class="n">_model</span><span class="p">,</span> <span class="s2">"vocabulary_"</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s2">"The tfidf vector is not fitted"</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="n">NotFittedError</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">Path</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"No model fitted, but file already exists. Importing..."</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">Path</span><span class="p">(</span><span class="n">init</span><span class="p">)</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"No model fitted, but file already exists. Importing..."</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span>

    <span class="n">df</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">"tokens"</span><span class="p">:</span> <span class="n">transformer</span><span class="o">.</span><span class="n">vocab_</span><span class="p">,</span>
                <span class="s2">"NE"</span><span class="p">:</span> <span class="s2">""</span><span class="p">,</span>
                <span class="s2">"alias"</span><span class="p">:</span> <span class="s2">""</span><span class="p">,</span>
                <span class="s2">"notes"</span><span class="p">:</span> <span class="s2">""</span><span class="p">,</span>
                <span class="s2">"score"</span><span class="p">:</span> <span class="n">transformer</span><span class="o">.</span><span class="n">scores_</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="c1"># .loc[:,["tokens", "NE", "alias", "notes", "score"]]</span>
        <span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="p">[</span><span class="o">~</span><span class="n">df</span><span class="o">.</span><span class="n">tokens</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="s2">"first"</span><span class="p">)])</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">"tokens"</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">Path</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
            <span class="n">init</span> <span class="o">=</span> <span class="n">filename</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"attempting to initialize with pre-existing vocab"</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span><span class="o">.</span><span class="n">NE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">df</span><span class="o">.</span><span class="n">alias</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">df</span><span class="o">.</span><span class="n">notes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="n">Path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">init</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>  <span class="c1"># filename is passed</span>
            <span class="n">df_import</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c1"># assume input pandas df</span>
                <span class="n">df_import</span> <span class="o">=</span> <span class="n">init</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">"File not Found! Can't import!"</span><span class="p">)</span>
                <span class="k">raise</span>
        <span class="n">df</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">df_import</span><span class="p">)</span>
        <span class="c1"># print('intialized successfully!')</span>
        <span class="n">df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s2">""</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"saved locally!"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span>
</code></pre></div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="nestor.keyword.get_multilabel_representation">
<code class="highlight language-python"><span class="n">get_multilabel_representation</span><span class="p">(</span><span class="n">tag_df</span><span class="p">)</span></code>
</h2>
<div class="doc doc-contents">
<p>Turn binary tag occurrences into strings of comma-separated tags</p>
<p>Given a hierarchical column-set of (entity-types, tag), where each row is
a document and the binary-valued elements indicate occurrence
(see <code>nestor.tag_extractor</code>), use this to get something a little more
human-readable. Columns will be entity-types, with elements as
comma-separated strings of tags.</p>
<p>Uses some hacks, since categorical from strings tends to assume single (not
multi-label) categories per-document. Likely to be re-factored in the future,
but used for the <code>readable=True</code> flag in <code>tag_extractor</code>.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tag_df</code></td>
<td><code>pd.DataFrame</code></td>
<td><p>binary occurrence matrix from <code>tag_extractor</code> </p></td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pd.DataFrame</code></td>
<td><p>document matrix with columns of tag-types, elements of
comma-separated tags of that type. </p></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_multilabel_representation</span><span class="p">(</span><span class="n">tag_df</span><span class="p">):</span>
    <span class="sd">"""Turn binary tag occurrences into strings of comma-separated tags</span>

<span class="sd">    Given a hierarchical column-set of (entity-types, tag), where each row is</span>
<span class="sd">    a document and the binary-valued elements indicate occurrence</span>
<span class="sd">    (see `nestor.tag_extractor`), use this to get something a little more</span>
<span class="sd">    human-readable. Columns will be entity-types, with elements as</span>
<span class="sd">    comma-separated strings of tags.</span>

<span class="sd">    Uses some hacks, since categorical from strings tends to assume single (not</span>
<span class="sd">    multi-label) categories per-document. Likely to be re-factored in the future,</span>
<span class="sd">    but used for the `readable=True` flag in `tag_extractor`.</span>

<span class="sd">    Args:</span>
<span class="sd">      tag_df (pd.DataFrame): binary occurrence matrix from `tag_extractor` </span>

<span class="sd">    Returns:</span>
<span class="sd">       pd.DataFrame: document matrix with columns of tag-types, elements of</span>
<span class="sd">       comma-separated tags of that type. </span>

<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">_get_readable_tag_df</span><span class="p">(</span><span class="n">tag_df</span><span class="p">)</span>
</code></pre></div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="nestor.keyword.get_tag_completeness">
<code class="highlight language-python"><span class="n">get_tag_completeness</span><span class="p">(</span><span class="n">tag_df</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>
</h2>
<div class="doc doc-contents">
<p>completeness, emptiness, and histograms in-between</p>
<p>It's hard to estimate "how good of a job you've done" at annotating your
data. One way is to calculate the fraction of documents where all tokens
have been mapped to their normalized form (a tag). Conversely, the fraction
that have no tokens normalized, at all.</p>
<p>Interpolating between those extremes, we can think of the Positive
Predictive Value (PPV, also known as Precision) of our annotations: of the
tokens/concepts not cleaned out (ostensibly, the <em>relevant</em> ones, how many
have been retrieved (i.e. mapped to a known tag)?</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tag_df</code></td>
<td><code>pd.DataFrame</code></td>
<td><p>hierarchical-column df containing</p></td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tuple</code></td>
<td><p>tuple containing:</p>
<pre><code>tag_pct(pd.Series): PPV/precision for all documents, useful for e.g. histograms
tag_comp(float): Fraction of documents that are *completely* tagged
tag_empt(float): Fraction of documents that are completely *untagged*
</code></pre></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_tag_completeness</span><span class="p">(</span><span class="n">tag_df</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">"""completeness, emptiness, and histograms in-between</span>

<span class="sd">    It's hard to estimate "how good of a job you've done" at annotating your</span>
<span class="sd">    data. One way is to calculate the fraction of documents where all tokens</span>
<span class="sd">    have been mapped to their normalized form (a tag). Conversely, the fraction</span>
<span class="sd">    that have no tokens normalized, at all.</span>

<span class="sd">    Interpolating between those extremes, we can think of the Positive</span>
<span class="sd">    Predictive Value (PPV, also known as Precision) of our annotations: of the</span>
<span class="sd">    tokens/concepts not cleaned out (ostensibly, the *relevant* ones, how many</span>
<span class="sd">    have been retrieved (i.e. mapped to a known tag)?</span>

<span class="sd">    Args:</span>
<span class="sd">      tag_df (pd.DataFrame): hierarchical-column df containing</span>

<span class="sd">    Returns:</span>
<span class="sd">       tuple: tuple containing:</span>

<span class="sd">           tag_pct(pd.Series): PPV/precision for all documents, useful for e.g. histograms</span>
<span class="sd">           tag_comp(float): Fraction of documents that are *completely* tagged</span>
<span class="sd">           tag_empt(float): Fraction of documents that are completely *untagged*</span>

<span class="sd">    """</span>

    <span class="n">all_empt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">tag_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">tag_pct</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span>
        <span class="n">tag_df</span><span class="o">.</span><span class="n">get</span><span class="p">([</span><span class="s2">"NA"</span><span class="p">,</span> <span class="s2">"U"</span><span class="p">],</span> <span class="n">all_empt</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">tag_df</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>  <span class="c1"># TODO: if they tag everything?</span>

    <span class="n">tag_comp</span> <span class="o">=</span> <span class="p">(</span><span class="n">tag_df</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"NA"</span><span class="p">,</span> <span class="n">all_empt</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">tag_empt</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">tag_df</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"I"</span><span class="p">,</span> <span class="n">all_empt</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">tag_df</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"P"</span><span class="p">,</span> <span class="n">all_empt</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">tag_df</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"S"</span><span class="p">,</span> <span class="n">all_empt</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_report_completeness</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Complete Docs: </span><span class="si">{</span><span class="n">tag_comp</span><span class="si">}</span><span class="s2">, or </span><span class="si">{</span><span class="n">tag_comp</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">tag_df</span><span class="p">)</span><span class="si">:</span><span class="s2">.2%</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Tag completeness: </span><span class="si">{</span><span class="n">tag_pct</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> +/- </span><span class="si">{</span><span class="n">tag_pct</span><span class="o">.</span><span class="n">std</span><span class="p">()</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Empty Docs: </span><span class="si">{</span><span class="n">tag_empt</span><span class="si">}</span><span class="s2">, or </span><span class="si">{</span><span class="n">tag_empt</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">tag_df</span><span class="p">)</span><span class="si">:</span><span class="s2">.2%</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">_report_completeness</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">tag_pct</span><span class="p">,</span> <span class="n">tag_comp</span><span class="p">,</span> <span class="n">tag_empt</span>
</code></pre></div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="nestor.keyword.iob_extractor">
<code class="highlight language-python"><span class="n">iob_extractor</span><span class="p">(</span><span class="n">raw_text</span><span class="p">,</span> <span class="n">vocab_df_1grams</span><span class="p">,</span> <span class="n">vocab_df_ngrams</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>
</h2>
<div class="doc doc-contents">
<p>Use Nestor named entity tags to create IOB format output for NER tasks</p>
<p>This function provides IOB-formatted tagged text, which allows for further NLP analysis. In the output,
each token is listed sequentially, as they appear in the raw text. Inside and Beginning Tokens are labeled with
"I-" or "B-" and their Named Entity tags; any multi-token entities all receive the same label.
Untagged tokens are labeled as "O" (Outside).</p>
<p>Example output (in this example, "PI" is "Problem Item":</p>
<p>token | NE | doc_id
an | O | 0
oil | B-PI | 0
leak | I-PI | 0</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>raw_text</code></td>
<td><code>pd.Series</code></td>
<td><p>contains jargon/slang-filled raw text to be tagged</p></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>vocab_df_1grams</code></td>
<td><code>pd.DataFrame</code></td>
<td><p>An existing vocabulary dataframe or .csv filename, expected in the format of
 kex.generate_vocabulary_df(), containing tagged 1-gram tokens
vocab_df_ngrams (pd.DataFrame, optional): An existing vocabulary dataframe or .csv filename, expected in
the format of kex.generate_vocabulary_df(), containing tagged n-gram tokens (Default value = None)</p></td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pd.DataFrame</code></td>
<td><p>contains row for each token ("token", "NE" (IOB format tag), and "doc_id")</p></td>
</tr>
</tbody>
</table> <h4 id="nestor.keyword.iob_extractor--parameters">Parameters</h4>
<p>raw_text
vocab_df_1grams
vocab_df_ngrams</p>
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">iob_extractor</span><span class="p">(</span><span class="n">raw_text</span><span class="p">,</span> <span class="n">vocab_df_1grams</span><span class="p">,</span> <span class="n">vocab_df_ngrams</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""Use Nestor named entity tags to create IOB format output for NER tasks</span>

<span class="sd">    This function provides IOB-formatted tagged text, which allows for further NLP analysis. In the output,</span>
<span class="sd">    each token is listed sequentially, as they appear in the raw text. Inside and Beginning Tokens are labeled with</span>
<span class="sd">    "I-" or "B-" and their Named Entity tags; any multi-token entities all receive the same label.</span>
<span class="sd">    Untagged tokens are labeled as "O" (Outside).</span>

<span class="sd">    Example output (in this example, "PI" is "Problem Item":</span>

<span class="sd">    token | NE | doc_id</span>
<span class="sd">    an | O | 0</span>
<span class="sd">    oil | B-PI | 0</span>
<span class="sd">    leak | I-PI | 0</span>

<span class="sd">    Args:</span>
<span class="sd">       raw_text (pd.Series): contains jargon/slang-filled raw text to be tagged</span>
<span class="sd">       vocab_df_1grams (pd.DataFrame): An existing vocabulary dataframe or .csv filename, expected in the format of</span>
<span class="sd">           kex.generate_vocabulary_df(), containing tagged 1-gram tokens</span>
<span class="sd">        vocab_df_ngrams (pd.DataFrame, optional): An existing vocabulary dataframe or .csv filename, expected in</span>
<span class="sd">        the format of kex.generate_vocabulary_df(), containing tagged n-gram tokens (Default value = None)</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: contains row for each token ("token", "NE" (IOB format tag), and "doc_id")</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    raw_text</span>
<span class="sd">    vocab_df_1grams</span>
<span class="sd">    vocab_df_ngrams</span>
<span class="sd">    """</span>

    <span class="c1"># Create IOB output DataFrame</span>
    <span class="c1"># iob = pd.DataFrame(columns=["token", "NE", "doc_id"])</span>

    <span class="k">if</span> <span class="n">vocab_df_ngrams</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Concatenate 1gram and ngram dataframes</span>
        <span class="n">vocab_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">vocab_df_1grams</span><span class="p">,</span> <span class="n">vocab_df_ngrams</span><span class="p">])</span>
        <span class="c1"># Get aliased text using ngrams</span>
        <span class="c1"># raw_text = token_to_alias(raw_text, vocab_df_ngrams)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Only use 1gram vocabulary provided</span>
        <span class="n">vocab_df</span> <span class="o">=</span> <span class="n">vocab_df_1grams</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Get aliased text</span>
        <span class="c1"># raw_text = token_to_alias(raw_text, vocab_df_1grams)</span>
        <span class="c1">#</span>
    <span class="n">vocab_thesaurus</span> <span class="o">=</span> <span class="n">vocab_df</span><span class="o">.</span><span class="n">alias</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
    <span class="n">NE_thesaurus</span> <span class="o">=</span> <span class="n">vocab_df</span><span class="o">.</span><span class="n">NE</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s2">"U"</span><span class="p">)</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

    <span class="n">rx_vocab</span> <span class="o">=</span> <span class="n">regex_match_vocab</span><span class="p">(</span><span class="n">vocab_thesaurus</span><span class="p">,</span> <span class="n">tokenize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># rx_NE = regex_match_vocab(NE_thesaurus)</span>
    <span class="c1">#</span>
    <span class="k">def</span> <span class="nf">beginning_token</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">"""after tokens are split and iob column exists"""</span>
        <span class="n">b_locs</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">"token_id"</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">nth</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">index</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">b_locs</span><span class="p">],</span> <span class="s2">"iob"</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"B"</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="k">def</span> <span class="nf">outside_token</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">"""after tokens are split and iob,NE columns exist"""</span>
        <span class="n">is_out</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">"NE"</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">nestorParams</span><span class="o">.</span><span class="n">holes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">iob</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s2">"iob"</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">is_out</span><span class="p">,</span> <span class="s2">"O"</span><span class="p">))</span>

    <span class="n">tidy_tokens</span> <span class="o">=</span> <span class="p">(</span>  <span class="c1"># unpivot the text into one-known-token-per-row</span>
        <span class="n">raw_text</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">"text"</span><span class="p">)</span>
        <span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="s2">"doc_id"</span><span class="p">)</span>
        <span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">rx_vocab</span><span class="p">)</span>
        <span class="c1"># longer series, one-row-per-token</span>
        <span class="o">.</span><span class="n">explode</span><span class="p">()</span>
        <span class="c1"># it's a dataframe now, with doc_id column</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="c1"># map tokens to NE, _fast tho_</span>
        <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">NE</span><span class="o">=</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">regex_thesaurus_normalizer</span><span class="p">(</span><span class="n">NE_thesaurus</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">text</span><span class="p">))</span>
        <span class="c1"># regex replace doesnt like nan, so we find the non-vocab tokens and make them unknown</span>
        <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">NE</span><span class="o">=</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">NE</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">NE</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">NE_thesaurus</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="s2">"U"</span><span class="p">))</span>
        <span class="c1"># now split on spaces and underscores (nestor's compound tokens)</span>
        <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">token</span><span class="o">=</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s2">"[_\s]"</span><span class="p">))</span>
        <span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="s2">"token_id"</span><span class="p">)</span>  <span class="c1"># keep track of which nestor token was used</span>
        <span class="o">.</span><span class="n">explode</span><span class="p">(</span><span class="s2">"token"</span><span class="p">)</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">iob</span><span class="o">=</span><span class="s2">"I"</span><span class="p">)</span>
        <span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">beginning_token</span><span class="p">)</span>
        <span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">outside_token</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">iob</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">tidy_tokens</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">[</span><span class="s2">"token"</span><span class="p">,</span> <span class="s2">"NE"</span><span class="p">,</span> <span class="s2">"doc_id"</span><span class="p">]]</span>
        <span class="o">.</span><span class="n">assign</span><span class="p">(</span>
            <span class="n">NE</span><span class="o">=</span><span class="n">tidy_tokens</span><span class="p">[</span><span class="s2">"NE"</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">tidy_tokens</span><span class="p">[</span><span class="s2">"iob"</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"O"</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># remove unused NE's</span>
        <span class="o">.</span><span class="n">assign</span><span class="p">(</span>
            <span class="n">NE</span><span class="o">=</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">tidy_tokens</span><span class="p">[</span><span class="s2">"iob"</span><span class="p">]</span>
            <span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">"NE"</span><span class="p">],</span> <span class="n">sep</span><span class="o">=</span><span class="s2">"-"</span><span class="p">,</span> <span class="n">na_rep</span><span class="o">=</span><span class="s2">""</span><span class="p">)</span>
            <span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">"-"</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># concat iob-NE</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">iob</span>
</code></pre></div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="nestor.keyword.ngram_automatch">
<code class="highlight language-python"><span class="n">ngram_automatch</span><span class="p">(</span><span class="n">voc1</span><span class="p">,</span> <span class="n">voc2</span><span class="p">)</span></code>
</h2>
<div class="doc doc-contents">
<p>auto-match tag combinations using <code>nestorParams.entity_rules_map</code></p>
<p>Experimental method to auto-match tag combinations into higher-level
concepts, primarily to suggest compound entity types to a user.</p>
<p>Used in <code>nestor.ui</code></p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>voc1</code></td>
<td><code>pd.DataFrame</code></td>
<td><p>known 1-gram token-&gt;tag mapping, with types</p></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>voc2</code></td>
<td><code>pd.DataFrame</code></td>
<td><p>current 2-gram map, with missing types to fill in from 1-grams</p></td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pd.DataFrame</code></td>
<td><p>new 2-gram map, with type combinations partially filled (no alias')</p></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">ngram_automatch</span><span class="p">(</span><span class="n">voc1</span><span class="p">,</span> <span class="n">voc2</span><span class="p">):</span>
    <span class="sd">"""auto-match tag combinations using `nestorParams.entity_rules_map`</span>

<span class="sd">    Experimental method to auto-match tag combinations into higher-level</span>
<span class="sd">    concepts, primarily to suggest compound entity types to a user.</span>

<span class="sd">    Used in ``nestor.ui``</span>

<span class="sd">    Args:</span>
<span class="sd">      voc1 (pd.DataFrame): known 1-gram token-&gt;tag mapping, with types</span>
<span class="sd">      voc2 (pd.DataFrame): current 2-gram map, with missing types to fill in from 1-grams</span>

<span class="sd">    Returns:</span>
<span class="sd">      pd.DataFrame: new 2-gram map, with type combinations partially filled (no alias')</span>

<span class="sd">    """</span>

    <span class="n">NE_map</span> <span class="o">=</span> <span class="n">nestorParams</span><span class="o">.</span><span class="n">entity_rules_map</span>

    <span class="n">vocab</span> <span class="o">=</span> <span class="n">voc1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">vocab</span><span class="o">.</span><span class="n">NE</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">""</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># first we need to substitute alias' for their NE identifier</span>
    <span class="n">NE_dict</span> <span class="o">=</span> <span class="n">vocab</span><span class="o">.</span><span class="n">NE</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s2">"NA"</span><span class="p">)</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

    <span class="n">NE_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
        <span class="n">vocab</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s2">"NA"</span><span class="p">)</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">()[[</span><span class="s2">"NE"</span><span class="p">,</span> <span class="s2">"alias"</span><span class="p">]]</span>
        <span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
        <span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">"alias"</span><span class="p">)</span>
        <span class="o">.</span><span class="n">NE</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="n">_</span> <span class="o">=</span> <span class="n">NE_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">""</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="n">NE_text</span> <span class="o">=</span> <span class="n">regex_thesaurus_normalizer</span><span class="p">(</span><span class="n">NE_dict</span><span class="p">,</span> <span class="n">voc2</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="c1"># now we have NE-soup/DNA of the original text.</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">voc2</span><span class="o">.</span><span class="n">alias</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
        <span class="s2">""</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="p">)</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>  <span class="c1"># don't overwrite the NE's the user has input (i.e. alias != NaN)</span>
    <span class="n">voc2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="s2">"NE"</span><span class="p">]</span> <span class="o">=</span> <span class="n">NE_text</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="c1"># track all combinations of NE types (cartesian prod)</span>

    <span class="c1"># apply rule substitutions that are defined</span>
    <span class="n">voc2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="s2">"NE"</span><span class="p">]</span> <span class="o">=</span> <span class="n">voc2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="s2">"NE"</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">NE_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">""</span><span class="p">)</span>
    <span class="p">)</span>  <span class="c1"># TODO ne_sub matching issue??  # special logic for custom NE type-combinations (config.yaml)</span>

    <span class="k">return</span> <span class="n">voc2</span>
</code></pre></div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="nestor.keyword.ngram_keyword_pipe">
<code class="highlight language-python"><span class="n">ngram_keyword_pipe</span><span class="p">(</span><span class="n">raw_text</span><span class="p">,</span> <span class="n">vocab</span><span class="p">,</span> <span class="n">vocab2</span><span class="p">)</span></code>
</h2>
<div class="doc doc-contents">
<p>Experimental pipeline for one-shot n-gram extraction from raw text.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>raw_text</code></td>
<td><code></code></td>
<td></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>vocab</code></td>
<td><code></code></td>
<td></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>vocab2</code></td>
<td><code></code></td>
<td></td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">ngram_keyword_pipe</span><span class="p">(</span><span class="n">raw_text</span><span class="p">,</span> <span class="n">vocab</span><span class="p">,</span> <span class="n">vocab2</span><span class="p">):</span>
    <span class="sd">"""Experimental pipeline for one-shot n-gram extraction from raw text.</span>

<span class="sd">    Args:</span>
<span class="sd">      raw_text: </span>
<span class="sd">      vocab: </span>
<span class="sd">      vocab2: </span>

<span class="sd">    Returns:</span>

<span class="sd">    """</span>
    <span class="kn">import</span> <span class="nn">warnings</span>

    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">"This function is deprecated! Use `ngram_vocab_builder`."</span><span class="p">,</span>
        <span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"calculating the extracted tags and statistics..."</span><span class="p">)</span>
    <span class="c1"># do 1-grams</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2"> ONE GRAMS..."</span><span class="p">)</span>
    <span class="n">tex</span> <span class="o">=</span> <span class="n">TokenExtractor</span><span class="p">()</span>
    <span class="n">tex2</span> <span class="o">=</span> <span class="n">TokenExtractor</span><span class="p">(</span><span class="n">ngram_range</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">tex</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">raw_text</span><span class="p">)</span>  <span class="c1"># bag of words matrix.</span>
    <span class="n">tag1_df</span> <span class="o">=</span> <span class="n">tag_extractor</span><span class="p">(</span><span class="n">tex</span><span class="p">,</span> <span class="n">raw_text</span><span class="p">,</span> <span class="n">vocab_df</span><span class="o">=</span><span class="n">vocab</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">vocab</span><span class="o">.</span><span class="n">alias</span><span class="o">.</span><span class="n">notna</span><span class="p">()])</span>
    <span class="n">vocab_combo</span><span class="p">,</span> <span class="n">tex3</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">ngram_vocab_builder</span><span class="p">(</span><span class="n">raw_text</span><span class="p">,</span> <span class="n">vocab</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="n">vocab2</span><span class="p">)</span>

    <span class="n">tex2</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">r1</span><span class="p">)</span>
    <span class="n">tag2_df</span> <span class="o">=</span> <span class="n">tag_extractor</span><span class="p">(</span><span class="n">tex2</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">vocab_df</span><span class="o">=</span><span class="n">vocab2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">vocab2</span><span class="o">.</span><span class="n">alias</span><span class="o">.</span><span class="n">notna</span><span class="p">()])</span>
    <span class="n">tag3_df</span> <span class="o">=</span> <span class="n">tag_extractor</span><span class="p">(</span>
        <span class="n">tex3</span><span class="p">,</span>
        <span class="n">r2</span><span class="p">,</span>
        <span class="n">vocab_df</span><span class="o">=</span><span class="n">vocab_combo</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">vocab_combo</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">vocab2</span><span class="o">.</span><span class="n">alias</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">)],</span>
    <span class="p">)</span>

    <span class="n">tags_df</span> <span class="o">=</span> <span class="n">tag1_df</span><span class="o">.</span><span class="n">combine_first</span><span class="p">(</span><span class="n">tag2_df</span><span class="p">)</span><span class="o">.</span><span class="n">combine_first</span><span class="p">(</span><span class="n">tag3_df</span><span class="p">)</span>

    <span class="n">relation_df</span> <span class="o">=</span> <span class="n">pick_tag_types</span><span class="p">(</span><span class="n">tags_df</span><span class="p">,</span> <span class="n">nestorParams</span><span class="o">.</span><span class="n">derived</span><span class="p">)</span>

    <span class="n">tag_df</span> <span class="o">=</span> <span class="n">pick_tag_types</span><span class="p">(</span><span class="n">tags_df</span><span class="p">,</span> <span class="n">nestorParams</span><span class="o">.</span><span class="n">atomics</span> <span class="o">+</span> <span class="n">nestorParams</span><span class="o">.</span><span class="n">holes</span> <span class="o">+</span> <span class="p">[</span><span class="s2">"NA"</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">tag_df</span><span class="p">,</span> <span class="n">relation_df</span>
</code></pre></div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="nestor.keyword.ngram_vocab_builder">
<code class="highlight language-python"><span class="n">ngram_vocab_builder</span><span class="p">(</span><span class="n">raw_text</span><span class="p">,</span> <span class="n">vocab1</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>
</h2>
<div class="doc doc-contents">
<p>complete pipeline for constructing higher-order tags</p>
<p>A useful technique for analysts is to use their tags like lego-blocks,
building up compound concepts from atomic tags. Nestor calls these <em>derived</em>
entities, and are determined by <code>nestorParams.derived</code>. It is possible to
construct new derived types on the fly whenever atomic or derived types are
encountered together that match a "rule" set forth by the user. These are
found in <code>nestorParams.entity_rules_map</code>.</p>
<p>Doing this in pandas and sklearn requires a bit of maneuvering with the
<code>TokenExtractor</code> objects, <code>token_to_alias</code>, and <code>ngram_automatch</code>.
The behavior of this function is to either produce a new ngram list from
scratch using the 1-grams and the original raw-text, or to take existing
n-gram mappings and add novel derived types to them.</p>
<p>This is a high-level function that may hide a lot of the other function calls.
IT MAY SLOW DOWN YOUR CODE. The primary use is within interactive UIs that
require a stream of new suggested derived-type instances, given user
activity making new atomic instances.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>raw_text(pd.Series)</code></td>
<td><code></code></td>
<td><p>original merged text (output from <code>NLPSelect</code>)</p></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>vocab1(pd.DataFrame)</code></td>
<td><code></code></td>
<td><p>known 1-gram token-&gt;tag mapping (w/ aliases)</p></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>init(pd.DataFrame)</code></td>
<td><code></code></td>
<td><p>2-gram mapping, known a priori (could be a prev. output of this function., optional):  (Default value = None)</p></td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(tuple)</code></td>
<td><p>tuple contaning:
   vocab2(pd.DataFrame): new/updated n-gram mapping
   tex(TokenExtractor): now-trained transformer that contains n-gram tf-idf scores, etc.
   replaced_text(pd.Series): raw text whose 1-gram tokens have been replaced with known tags
   replaced_again(pd.Series): replaced_text whose atomic tags have been replaced with known derived types.</p></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">ngram_vocab_builder</span><span class="p">(</span><span class="n">raw_text</span><span class="p">,</span> <span class="n">vocab1</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""complete pipeline for constructing higher-order tags</span>

<span class="sd">    A useful technique for analysts is to use their tags like lego-blocks,</span>
<span class="sd">    building up compound concepts from atomic tags. Nestor calls these *derived*</span>
<span class="sd">    entities, and are determined by `nestorParams.derived`. It is possible to</span>
<span class="sd">    construct new derived types on the fly whenever atomic or derived types are</span>
<span class="sd">    encountered together that match a "rule" set forth by the user. These are</span>
<span class="sd">    found in `nestorParams.entity_rules_map`.</span>

<span class="sd">    Doing this in pandas and sklearn requires a bit of maneuvering with the</span>
<span class="sd">    `TokenExtractor` objects, `token_to_alias`, and `ngram_automatch`.</span>
<span class="sd">    The behavior of this function is to either produce a new ngram list from</span>
<span class="sd">    scratch using the 1-grams and the original raw-text, or to take existing</span>
<span class="sd">    n-gram mappings and add novel derived types to them.</span>

<span class="sd">    This is a high-level function that may hide a lot of the other function calls.</span>
<span class="sd">    IT MAY SLOW DOWN YOUR CODE. The primary use is within interactive UIs that</span>
<span class="sd">    require a stream of new suggested derived-type instances, given user</span>
<span class="sd">    activity making new atomic instances.</span>

<span class="sd">    Args:</span>
<span class="sd">      raw_text(pd.Series): original merged text (output from `NLPSelect`)</span>
<span class="sd">      vocab1(pd.DataFrame): known 1-gram token-&gt;tag mapping (w/ aliases)</span>
<span class="sd">      init(pd.DataFrame): 2-gram mapping, known a priori (could be a prev. output of this function., optional):  (Default value = None)</span>

<span class="sd">    Returns:</span>
<span class="sd">      (tuple): tuple contaning:</span>
<span class="sd">         vocab2(pd.DataFrame): new/updated n-gram mapping</span>
<span class="sd">         tex(TokenExtractor): now-trained transformer that contains n-gram tf-idf scores, etc.</span>
<span class="sd">         replaced_text(pd.Series): raw text whose 1-gram tokens have been replaced with known tags</span>
<span class="sd">         replaced_again(pd.Series): replaced_text whose atomic tags have been replaced with known derived types.</span>

<span class="sd">    """</span>
    <span class="c1"># raw_text, with token--&gt;alias replacement</span>
    <span class="n">replaced_text</span> <span class="o">=</span> <span class="n">token_to_alias</span><span class="p">(</span><span class="n">raw_text</span><span class="p">,</span> <span class="n">vocab1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tex</span> <span class="o">=</span> <span class="n">TokenExtractor</span><span class="p">(</span><span class="n">ngram_range</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># new extractor (note 2-gram)</span>
        <span class="n">tex</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">replaced_text</span><span class="p">)</span>
        <span class="n">vocab2</span> <span class="o">=</span> <span class="n">generate_vocabulary_df</span><span class="p">(</span><span class="n">tex</span><span class="p">)</span>
        <span class="n">replaced_again</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">init</span><span class="o">.</span><span class="n">NE</span><span class="p">,</span> <span class="n">nestorParams</span><span class="o">.</span><span class="n">atomics</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">init</span><span class="o">.</span><span class="n">alias</span> <span class="o">!=</span> <span class="s2">""</span><span class="p">)</span>
        <span class="c1"># now we need the 2grams that were annotated as 1grams</span>
        <span class="n">replaced_again</span> <span class="o">=</span> <span class="n">token_to_alias</span><span class="p">(</span>
            <span class="n">replaced_text</span><span class="p">,</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">vocab1</span><span class="p">,</span> <span class="n">init</span><span class="p">[</span><span class="n">mask</span><span class="p">]])</span>
            <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
            <span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">"tokens"</span><span class="p">])</span>
            <span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">"tokens"</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">tex</span> <span class="o">=</span> <span class="n">TokenExtractor</span><span class="p">(</span><span class="n">ngram_range</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">tex</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">replaced_again</span><span class="p">)</span>
        <span class="n">new_vocab</span> <span class="o">=</span> <span class="n">generate_vocabulary_df</span><span class="p">(</span><span class="n">tex</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="n">init</span><span class="p">)</span>
        <span class="n">vocab2</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">init</span><span class="p">,</span> <span class="n">new_vocab</span><span class="p">])</span>
            <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
            <span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">"tokens"</span><span class="p">])</span>
            <span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">"tokens"</span><span class="p">)</span>
            <span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">"score"</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">vocab2</span><span class="p">,</span> <span class="n">tex</span><span class="p">,</span> <span class="n">replaced_text</span><span class="p">,</span> <span class="n">replaced_again</span>
</code></pre></div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="nestor.keyword.pick_tag_types">
<code class="highlight language-python"><span class="n">pick_tag_types</span><span class="p">(</span><span class="n">tag_df</span><span class="p">,</span> <span class="n">typelist</span><span class="p">)</span></code>
</h2>
<div class="doc doc-contents">
<p>convenience function to pick out one entity type (top-lvl column)</p>
<p>tag_df (output from <code>tag_extractor</code>) contains multi-level columns. These can
be unwieldy, especially if one needs to focus on a particular tag type,
slicing by tag name. This function abstracts some of that logic away.</p>
<p>Gracefully finds columns that exist, ignoring ones you want that don't.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tag_df(pd.DataFrame)</code></td>
<td><code></code></td>
<td><p>binary tag occurrence matrix, as output by <code>tag_extractor</code></p></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>typelist(List[str])</code></td>
<td><code></code></td>
<td><p>names of entity types you want to slice from.</p></td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(pd.DataFrameo)</code></td>
<td><p>a sliced copy of <code>tag_df</code>, given <code>typelist</code></p></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">pick_tag_types</span><span class="p">(</span><span class="n">tag_df</span><span class="p">,</span> <span class="n">typelist</span><span class="p">):</span>
    <span class="sd">"""convenience function to pick out one entity type (top-lvl column)</span>

<span class="sd">    tag_df (output from `tag_extractor`) contains multi-level columns. These can</span>
<span class="sd">    be unwieldy, especially if one needs to focus on a particular tag type,</span>
<span class="sd">    slicing by tag name. This function abstracts some of that logic away.</span>

<span class="sd">    Gracefully finds columns that exist, ignoring ones you want that don't.</span>

<span class="sd">    Args:</span>
<span class="sd">      tag_df(pd.DataFrame): binary tag occurrence matrix, as output by `tag_extractor`</span>
<span class="sd">      typelist(List[str]): names of entity types you want to slice from.</span>

<span class="sd">    Returns:</span>
<span class="sd">      (pd.DataFrameo): a sliced copy of `tag_df`, given `typelist`</span>

<span class="sd">    """</span>
    <span class="n">df_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tag_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">available</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">typelist</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">df_types</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tag_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="nb">list</span><span class="p">(</span><span class="n">available</span><span class="p">)]</span>
</code></pre></div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="nestor.keyword.regex_match_vocab">
<code class="highlight language-python"><span class="n">regex_match_vocab</span><span class="p">(</span><span class="n">vocab_iter</span><span class="p">,</span> <span class="n">tokenize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>
</h2>
<div class="doc doc-contents">
<p>regex-based multi-replace</p>
<p>Fast way to get all matches for a list of vocabulary (e.g. to replace them with preferred labels).</p>
<p>NOTE: This will avoid nested matches by sorting the vocabulary by length! This means ambiguous substring
matches will default to the longest match, only.</p>
<blockquote>
<p>e.g. with vocabulary <code>['these','there', 'the']</code> and text <code>'there-in'</code>
the match will defer to <code>there</code> rather than <code>the</code>.</p>
</blockquote>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vocab_iter</code></td>
<td><code>Iterable[str]</code></td>
<td><p>container of strings. If a dict is pass, will operate on keys.</p></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>tokenize</code></td>
<td><code>bool</code></td>
<td><p>whether the vocab should include all valid token strings from tokenizer</p></td>
<td><code>False</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Pattern</code></td>
<td><p>re.Pattern: a compiled regex pattern for finding all vocabulary.</p></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">regex_match_vocab</span><span class="p">(</span><span class="n">vocab_iter</span><span class="p">,</span> <span class="n">tokenize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">:</span>
    <span class="sd">"""regex-based multi-replace</span>

<span class="sd">    Fast way to get all matches for a list of vocabulary (e.g. to replace them with preferred labels).</span>

<span class="sd">    NOTE: This will avoid nested matches by sorting the vocabulary by length! This means ambiguous substring</span>
<span class="sd">    matches will default to the longest match, only.</span>

<span class="sd">    &gt; e.g. with vocabulary `['these','there', 'the']` and text `'there-in'`</span>
<span class="sd">    &gt; the match will defer to `there` rather than `the`.</span>
<span class="sd">    Args:</span>
<span class="sd">      vocab_iter (Iterable[str]): container of strings. If a dict is pass, will operate on keys.</span>
<span class="sd">      tokenize (bool): whether the vocab should include all valid token strings from tokenizer</span>

<span class="sd">    Returns:</span>
<span class="sd">      re.Pattern: a compiled regex pattern for finding all vocabulary.</span>
<span class="sd">    """</span>
    <span class="n">sort</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">vocab_iter</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">vocab_str</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">"\b(?:"</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">"|"</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">,</span> <span class="n">sort</span><span class="p">))</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">")\b"</span>

    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">sort</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tokenize</span><span class="p">:</span>  <span class="c1"># just do tokenizer</span>
        <span class="k">return</span> <span class="n">nestorParams</span><span class="o">.</span><span class="n">token_pattern</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">sort</span><span class="p">:</span>
        <span class="n">rx_str</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">"(?!x)x"</span>  <span class="c1"># match nothing, ever</span>
    <span class="k">elif</span> <span class="n">tokenize</span><span class="p">:</span>
        <span class="c1"># the non-compiled token_pattern version accessed by __getitem__ (not property/attr)</span>
        <span class="n">rx_str</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">"(</span><span class="si">{}</span><span class="s2">|</span><span class="si">{}</span><span class="s2">)"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">vocab_str</span><span class="p">,</span> <span class="sa">r</span><span class="s2">"(?:"</span> <span class="o">+</span> <span class="n">nestorParams</span><span class="p">[</span><span class="s2">"token_pattern"</span><span class="p">]</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">")"</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># valid vocab -&gt; match them in order of len</span>
        <span class="n">rx_str</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">"\b("</span> <span class="o">+</span> <span class="s2">"|"</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">,</span> <span class="n">sort</span><span class="p">))</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">")\b"</span>

    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">rx_str</span><span class="p">)</span>
</code></pre></div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="nestor.keyword.regex_thesaurus_normalizer">
<code class="highlight language-python"><span class="n">regex_thesaurus_normalizer</span><span class="p">(</span><span class="n">thesaurus</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span></code>
</h2>
<div class="doc doc-contents">
<p>Quick way to replace text substrings in a Series with a dictionary of replacements (thesaurus)</p>
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">regex_thesaurus_normalizer</span><span class="p">(</span><span class="n">thesaurus</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
    <span class="sd">"""Quick way to replace text substrings in a Series with a dictionary of replacements (thesaurus)"""</span>
    <span class="n">rx</span> <span class="o">=</span> <span class="n">regex_match_vocab</span><span class="p">(</span><span class="n">thesaurus</span><span class="p">)</span>
    <span class="n">clean_text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">rx</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">match</span><span class="p">:</span> <span class="n">thesaurus</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">clean_text</span>
</code></pre></div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="nestor.keyword.tag_extractor">
<code class="highlight language-python"><span class="n">tag_extractor</span><span class="p">(</span><span class="n">transformer</span><span class="p">,</span> <span class="n">raw_text</span><span class="p">,</span> <span class="n">vocab_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">readable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">group_untagged</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>
</h2>
<div class="doc doc-contents">
<p>Turn TokenExtractor instances and raw-text into binary occurrences.</p>
<p>Wrapper for the TokenExtractor to streamline the generation of tags from text.
Determines the documents in <code>raw_text</code> that contain each of the tags in <code>vocab_df</code>,
using a TokenExtractor transformer object (i.e. the tfidf vocabulary).</p>
<p>As implemented, this function expects an existing transformer object, though in
the future this may be changed to a class-like functionality (e.g. sklearn's
AdaBoostClassifier, etc) which wraps a transformer into a new one.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>transformer</code></td>
<td><code>object KeywordExtractor</code></td>
<td><p>instantiated, can be pre-trained</p></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>raw_text</code></td>
<td><code>pd.Series</code></td>
<td><p>contains jargon/slang-filled raw text to be tagged</p></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>vocab_df</code></td>
<td><code>pd.DataFrame</code></td>
<td><p>An existing vocabulary dataframe or .csv filename, expected in the format of
 kex.generate_vocabulary_df(). (Default value = None)</p></td>
<td><code>None</code></td>
</tr>
<tr>
<td><code>readable</code></td>
<td><code>bool</code></td>
<td><p>whether to return readable, categorized, comma-sep str format (takes longer) (Default value = False)</p></td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>group_untagged</code></td>
<td><code>bool</code></td>
<td><p>whether to group untagged tokens into a catch-all "_untagged" tag</p></td>
<td><code>True</code></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pd.DataFrame</code></td>
<td><p>extracted tags for each document, whether binary indicator (default)
or in readable, categorized, comma-sep str format (readable=True, takes longer)</p></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">tag_extractor</span><span class="p">(</span>
    <span class="n">transformer</span><span class="p">,</span> <span class="n">raw_text</span><span class="p">,</span> <span class="n">vocab_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">readable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">group_untagged</span><span class="o">=</span><span class="kc">True</span>
<span class="p">):</span>
    <span class="sd">"""Turn TokenExtractor instances and raw-text into binary occurrences.</span>

<span class="sd">    Wrapper for the TokenExtractor to streamline the generation of tags from text.</span>
<span class="sd">    Determines the documents in `raw_text` that contain each of the tags in `vocab_df`,</span>
<span class="sd">    using a TokenExtractor transformer object (i.e. the tfidf vocabulary).</span>

<span class="sd">    As implemented, this function expects an existing transformer object, though in</span>
<span class="sd">    the future this may be changed to a class-like functionality (e.g. sklearn's</span>
<span class="sd">    AdaBoostClassifier, etc) which wraps a transformer into a new one.</span>

<span class="sd">    Args:</span>
<span class="sd">       transformer (object KeywordExtractor): instantiated, can be pre-trained</span>
<span class="sd">       raw_text (pd.Series): contains jargon/slang-filled raw text to be tagged</span>
<span class="sd">       vocab_df (pd.DataFrame, optional): An existing vocabulary dataframe or .csv filename, expected in the format of</span>
<span class="sd">           kex.generate_vocabulary_df(). (Default value = None)</span>
<span class="sd">       readable (bool, optional): whether to return readable, categorized, comma-sep str format (takes longer) (Default value = False)</span>
<span class="sd">       group_untagged (bool, optional):  whether to group untagged tokens into a catch-all "_untagged" tag</span>

<span class="sd">    Returns:</span>
<span class="sd">       pd.DataFrame: extracted tags for each document, whether binary indicator (default)</span>
<span class="sd">       or in readable, categorized, comma-sep str format (readable=True, takes longer)</span>

<span class="sd">    """</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">check_is_fitted</span><span class="p">(</span>
            <span class="n">transformer</span><span class="o">.</span><span class="n">_model</span><span class="p">,</span> <span class="s2">"vocabulary_"</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s2">"The tfidf vector is not fitted"</span>
        <span class="p">)</span>
        <span class="n">toks</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">raw_text</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">NotFittedError</span><span class="p">:</span>
        <span class="n">toks</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">raw_text</span><span class="p">)</span>

    <span class="n">vocab</span> <span class="o">=</span> <span class="n">generate_vocabulary_df</span><span class="p">(</span><span class="n">transformer</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="n">vocab_df</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">untagged_alias</span> <span class="o">=</span> <span class="s2">"_untagged"</span> <span class="k">if</span> <span class="n">group_untagged</span> <span class="k">else</span> <span class="n">vocab</span><span class="p">[</span><span class="s2">"tokens"</span><span class="p">]</span>
    <span class="n">v_filled</span> <span class="o">=</span> <span class="n">vocab</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="s2">"NE"</span><span class="p">:</span> <span class="p">{</span><span class="s2">""</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">},</span> <span class="s2">"alias"</span><span class="p">:</span> <span class="p">{</span><span class="s2">""</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">}})</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="s2">"NE"</span><span class="p">:</span> <span class="s2">"NA"</span><span class="p">,</span>  <span class="c1"># TODO make this optional</span>
            <span class="c1"># 'alias': vocab['tokens'],</span>
            <span class="c1"># "alias": "_untagged",  # currently combines all NA into 1, for weighted sum</span>
            <span class="s2">"alias"</span><span class="p">:</span> <span class="n">untagged_alias</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">group_untagged</span><span class="p">:</span>  <span class="c1"># makes no sense to keep NE for "_untagged" tags...</span>
        <span class="n">v_filled</span> <span class="o">=</span> <span class="n">v_filled</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span>
            <span class="n">NE</span><span class="o">=</span><span class="n">v_filled</span><span class="o">.</span><span class="n">NE</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">v_filled</span><span class="o">.</span><span class="n">alias</span> <span class="o">==</span> <span class="s2">"_untagged"</span><span class="p">,</span> <span class="s2">"NA"</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="n">sparse_dtype</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">SparseDtype</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">table</span> <span class="o">=</span> <span class="p">(</span>  <span class="c1"># more pandas-ey pivot, for future cat-types</span>
        <span class="n">v_filled</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">exists</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># placehold</span>
        <span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">"NE"</span><span class="p">,</span> <span class="s2">"alias"</span><span class="p">,</span> <span class="s2">"tokens"</span><span class="p">])[</span><span class="s2">"exists"</span><span class="p">]</span>
        <span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="s2">"tokens"</span><span class="p">)</span>
        <span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">sparse_dtype</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">toks</span><span class="p">[:,</span> <span class="n">transformer</span><span class="o">.</span><span class="n">ranks_</span><span class="p">]</span>
    <span class="n">A</span><span class="p">[</span><span class="n">A</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">docterm</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">from_spmatrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">v_filled</span><span class="p">[</span><span class="s2">"tokens"</span><span class="p">],)</span>

    <span class="n">tag_df</span> <span class="o">=</span> <span class="n">docterm</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>
    <span class="n">tag_df</span><span class="o">.</span><span class="n">rename_axis</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">readable</span><span class="p">:</span>
        <span class="n">tag_df</span> <span class="o">=</span> <span class="n">_get_readable_tag_df</span><span class="p">(</span><span class="n">tag_df</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tag_df</span>
</code></pre></div>
</details>
</div>
</div>
<div class="doc doc-object doc-function">
<h2 class="doc doc-heading" id="nestor.keyword.token_to_alias">
<code class="highlight language-python"><span class="n">token_to_alias</span><span class="p">(</span><span class="n">raw_text</span><span class="p">,</span> <span class="n">vocab</span><span class="p">)</span></code>
</h2>
<div class="doc doc-contents">
<p>Replaces known tokens with their "tag" form</p>
<p>Useful if normalized text is needed, i.e. using the token-&gt;tag map from some
known vocabulary list. As implemented, looks for the longest matched substrings
first, ensuring precedence for compound tags or similar spellings, e.g.
"thes-&gt;these" would get substituted before "the -&gt; [article]"</p>
<p>Needed for higher-order tag creation (see <code>nestor.keyword.ngram_vocab_builder</code>).</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>raw_text</code></td>
<td><code>pd.Series</code></td>
<td><p>contains text with known jargon, slang, etc</p></td>
<td><em>required</em></td>
</tr>
<tr>
<td><code>vocab</code></td>
<td><code>pd.DataFrame</code></td>
<td><p>contains alias' keyed on known slang, jargon, etc.</p></td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pd.Series</code></td>
<td><p>new text, with all slang/jargon replaced with unified tag representations</p></td>
</tr>
</tbody>
</table>
<details class="quote">
<summary>Source code in <code>nestor/keyword.py</code></summary>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">token_to_alias</span><span class="p">(</span><span class="n">raw_text</span><span class="p">,</span> <span class="n">vocab</span><span class="p">):</span>
    <span class="sd">"""Replaces known tokens with their "tag" form</span>

<span class="sd">    Useful if normalized text is needed, i.e. using the token-&gt;tag map from some</span>
<span class="sd">    known vocabulary list. As implemented, looks for the longest matched substrings</span>
<span class="sd">    first, ensuring precedence for compound tags or similar spellings, e.g.</span>
<span class="sd">    "thes-&gt;these" would get substituted before "the -&gt; [article]"</span>

<span class="sd">    Needed for higher-order tag creation (see `nestor.keyword.ngram_vocab_builder`).</span>

<span class="sd">    Args:</span>
<span class="sd">      raw_text (pd.Series): contains text with known jargon, slang, etc</span>
<span class="sd">      vocab (pd.DataFrame): contains alias' keyed on known slang, jargon, etc.</span>

<span class="sd">    Returns:</span>
<span class="sd">       pd.Series: new text, with all slang/jargon replaced with unified tag representations</span>

<span class="sd">    """</span>
    <span class="n">thes_dict</span> <span class="o">=</span> <span class="n">vocab</span><span class="p">[</span><span class="n">vocab</span><span class="o">.</span><span class="n">alias</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">""</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">notna</span><span class="p">()]</span><span class="o">.</span><span class="n">alias</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">regex_thesaurus_normalizer</span><span class="p">(</span><span class="n">thes_dict</span><span class="p">,</span> <span class="n">raw_text</span><span class="p">)</span>
</code></pre></div>
</details>
</div>
</div>
</div>
</div>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav aria-label="Footer" class="md-footer-nav__inner md-grid">
<a class="md-footer-nav__link md-footer-nav__link--prev" href="../settings/" rel="prev" title="settings">
<div class="md-footer-nav__button md-icon">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"></path></svg>
</div>
<div class="md-footer-nav__title">
<div class="md-ellipsis">
<span class="md-footer-nav__direction">
                  Previous
                </span>
                settings
              </div>
</div>
</a>
<a class="md-footer-nav__link md-footer-nav__link--next" href="../datasets/" rel="next" title="datasets">
<div class="md-footer-nav__title">
<div class="md-ellipsis">
<span class="md-footer-nav__direction">
                  Next
                </span>
                datasets
              </div>
</div>
<div class="md-footer-nav__button md-icon">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"></path></svg>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" rel="noopener" target="_blank">
          Material for MkDocs
        </a>
 ... <a class="link--pdf-download" download="" href="../../pdf/nestor-documentation.pdf" title="PDF">download PDF</a></div>
</div>
</div>
</footer>
</div>
<script src="../../assets/javascripts/vendor.2d1db4bd.min.js"></script>
<script src="../../assets/javascripts/bundle.6627ddf3.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script>
<script>
        app = initialize({
          base: "../..",
          features: [],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.5eca75d3.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
<script src="https://pages.nist.gov/nist-header-footer/js/jquery-1.9.0.min.js"></script>
<script src="https://pages.nist.gov/nist-header-footer/js/nist-header-footer.js"></script>
</body>
</html>